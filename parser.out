Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    SPACE

Grammar

Rule 0     S' -> statements
Rule 1     statements -> statement
Rule 2     statements -> statement NEWLINE statements
Rule 3     statements -> statement statements
Rule 4     statement -> assign
Rule 5     statement -> expr
Rule 6     statement -> input_stmt
Rule 7     statement -> print_stmt
Rule 8     statement -> if_stmt
Rule 9     statement -> for_stmt
Rule 10    statement -> while_stmt
Rule 11    assign -> ID EQUALS expr
Rule 12    expr -> expr PLUS term
Rule 13    expr -> expr MINUS term
Rule 14    expr -> term
Rule 15    expr -> LPAREN expr RPAREN
Rule 16    term -> term TIMES factor
Rule 17    term -> term DIVIDE factor
Rule 18    term -> factor
Rule 19    factor -> INTEGER
Rule 20    factor -> ID
Rule 21    factor -> STRING
Rule 22    factor -> FLOAT
Rule 23    input_stmt -> ID EQUALS input LPAREN RPAREN
Rule 24    print_stmt -> print LPAREN expr RPAREN
Rule 25    comp_op -> expr GREATER expr
Rule 26    comp_op -> expr LESS expr
Rule 27    comp_op -> expr EQUALTO expr
Rule 28    comp_op -> expr NOTEQUALTO expr
Rule 29    if_stmt -> if comp_op COLON block
Rule 30    if_stmt -> if comp_op COLON block elif_stmt
Rule 31    if_stmt -> if comp_op COLON block else_block
Rule 32    elif_stmt -> elif comp_op COLON block
Rule 33    elif_stmt -> elif comp_op COLON block elif_stmt
Rule 34    elif_stmt -> elif comp_op COLON block else_block
Rule 35    else_block -> else COLON block
Rule 36    block -> INDENT statements
Rule 37    block -> INDENT statements DEDENT
Rule 38    for_stmt -> for ID in range target_list COLON block
Rule 39    target_list -> expr
Rule 40    target_list -> LPAREN expr COMMA expr RPAREN
Rule 41    while_stmt -> while comp_op COLON block

Terminals, with rules where they appear

COLON                : 29 30 31 32 33 34 35 38 41
COMMA                : 40
COMMENT              : 
DEDENT               : 37
DIVIDE               : 17
EQUALS               : 11 23
EQUALTO              : 27
FLOAT                : 22
GREATER              : 25
ID                   : 11 20 23 38
INDENT               : 36 37
INTEGER              : 19
LESS                 : 26
LPAREN               : 15 23 24 40
MINUS                : 13
NEWLINE              : 2
NOTEQUALTO           : 28
PLUS                 : 12
RPAREN               : 15 23 24 40
SPACE                : 
STRING               : 21
TIMES                : 16
elif                 : 32 33 34
else                 : 35
error                : 
for                  : 38
if                   : 29 30 31
in                   : 38
input                : 23
print                : 24
range                : 38
while                : 41

Nonterminals, with rules where they appear

assign               : 4
block                : 29 30 31 32 33 34 35 38 41
comp_op              : 29 30 31 32 33 34 41
elif_stmt            : 30 33
else_block           : 31 34
expr                 : 5 11 12 13 15 24 25 25 26 26 27 27 28 28 39 40 40
factor               : 16 17 18
for_stmt             : 9
if_stmt              : 8
input_stmt           : 6
print_stmt           : 7
statement            : 1 2 3
statements           : 2 3 36 37 0
target_list          : 38
term                 : 12 13 14 16 17
while_stmt           : 10

Parsing method: LALR

state 0

    (0) S' -> . statements
    (1) statements -> . statement
    (2) statements -> . statement NEWLINE statements
    (3) statements -> . statement statements
    (4) statement -> . assign
    (5) statement -> . expr
    (6) statement -> . input_stmt
    (7) statement -> . print_stmt
    (8) statement -> . if_stmt
    (9) statement -> . for_stmt
    (10) statement -> . while_stmt
    (11) assign -> . ID EQUALS expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (23) input_stmt -> . ID EQUALS input LPAREN RPAREN
    (24) print_stmt -> . print LPAREN expr RPAREN
    (29) if_stmt -> . if comp_op COLON block
    (30) if_stmt -> . if comp_op COLON block elif_stmt
    (31) if_stmt -> . if comp_op COLON block else_block
    (38) for_stmt -> . for ID in range target_list COLON block
    (41) while_stmt -> . while comp_op COLON block
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    ID              shift and go to state 10
    LPAREN          shift and go to state 12
    print           shift and go to state 13
    if              shift and go to state 14
    for             shift and go to state 15
    while           shift and go to state 16
    INTEGER         shift and go to state 18
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    statements                     shift and go to state 1
    statement                      shift and go to state 2
    assign                         shift and go to state 3
    expr                           shift and go to state 4
    input_stmt                     shift and go to state 5
    print_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7
    for_stmt                       shift and go to state 8
    while_stmt                     shift and go to state 9
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 1

    (0) S' -> statements .



state 2

    (1) statements -> statement .
    (2) statements -> statement . NEWLINE statements
    (3) statements -> statement . statements
    (1) statements -> . statement
    (2) statements -> . statement NEWLINE statements
    (3) statements -> . statement statements
    (4) statement -> . assign
    (5) statement -> . expr
    (6) statement -> . input_stmt
    (7) statement -> . print_stmt
    (8) statement -> . if_stmt
    (9) statement -> . for_stmt
    (10) statement -> . while_stmt
    (11) assign -> . ID EQUALS expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (23) input_stmt -> . ID EQUALS input LPAREN RPAREN
    (24) print_stmt -> . print LPAREN expr RPAREN
    (29) if_stmt -> . if comp_op COLON block
    (30) if_stmt -> . if comp_op COLON block elif_stmt
    (31) if_stmt -> . if comp_op COLON block else_block
    (38) for_stmt -> . for ID in range target_list COLON block
    (41) while_stmt -> . while comp_op COLON block
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for print resolved as shift
  ! shift/reduce conflict for if resolved as shift
  ! shift/reduce conflict for for resolved as shift
  ! shift/reduce conflict for while resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
    $end            reduce using rule 1 (statements -> statement .)
    DEDENT          reduce using rule 1 (statements -> statement .)
    elif            reduce using rule 1 (statements -> statement .)
    else            reduce using rule 1 (statements -> statement .)
    NEWLINE         shift and go to state 21
    ID              shift and go to state 10
    LPAREN          shift and go to state 12
    print           shift and go to state 13
    if              shift and go to state 14
    for             shift and go to state 15
    while           shift and go to state 16
    INTEGER         shift and go to state 18
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

  ! NEWLINE         [ reduce using rule 1 (statements -> statement .) ]
  ! ID              [ reduce using rule 1 (statements -> statement .) ]
  ! LPAREN          [ reduce using rule 1 (statements -> statement .) ]
  ! print           [ reduce using rule 1 (statements -> statement .) ]
  ! if              [ reduce using rule 1 (statements -> statement .) ]
  ! for             [ reduce using rule 1 (statements -> statement .) ]
  ! while           [ reduce using rule 1 (statements -> statement .) ]
  ! INTEGER         [ reduce using rule 1 (statements -> statement .) ]
  ! STRING          [ reduce using rule 1 (statements -> statement .) ]
  ! FLOAT           [ reduce using rule 1 (statements -> statement .) ]

    statement                      shift and go to state 2
    statements                     shift and go to state 22
    assign                         shift and go to state 3
    expr                           shift and go to state 4
    input_stmt                     shift and go to state 5
    print_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7
    for_stmt                       shift and go to state 8
    while_stmt                     shift and go to state 9
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 3

    (4) statement -> assign .

    NEWLINE         reduce using rule 4 (statement -> assign .)
    ID              reduce using rule 4 (statement -> assign .)
    LPAREN          reduce using rule 4 (statement -> assign .)
    print           reduce using rule 4 (statement -> assign .)
    if              reduce using rule 4 (statement -> assign .)
    for             reduce using rule 4 (statement -> assign .)
    while           reduce using rule 4 (statement -> assign .)
    INTEGER         reduce using rule 4 (statement -> assign .)
    STRING          reduce using rule 4 (statement -> assign .)
    FLOAT           reduce using rule 4 (statement -> assign .)
    $end            reduce using rule 4 (statement -> assign .)
    DEDENT          reduce using rule 4 (statement -> assign .)
    elif            reduce using rule 4 (statement -> assign .)
    else            reduce using rule 4 (statement -> assign .)


state 4

    (5) statement -> expr .
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    NEWLINE         reduce using rule 5 (statement -> expr .)
    ID              reduce using rule 5 (statement -> expr .)
    LPAREN          reduce using rule 5 (statement -> expr .)
    print           reduce using rule 5 (statement -> expr .)
    if              reduce using rule 5 (statement -> expr .)
    for             reduce using rule 5 (statement -> expr .)
    while           reduce using rule 5 (statement -> expr .)
    INTEGER         reduce using rule 5 (statement -> expr .)
    STRING          reduce using rule 5 (statement -> expr .)
    FLOAT           reduce using rule 5 (statement -> expr .)
    $end            reduce using rule 5 (statement -> expr .)
    DEDENT          reduce using rule 5 (statement -> expr .)
    elif            reduce using rule 5 (statement -> expr .)
    else            reduce using rule 5 (statement -> expr .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 5

    (6) statement -> input_stmt .

    NEWLINE         reduce using rule 6 (statement -> input_stmt .)
    ID              reduce using rule 6 (statement -> input_stmt .)
    LPAREN          reduce using rule 6 (statement -> input_stmt .)
    print           reduce using rule 6 (statement -> input_stmt .)
    if              reduce using rule 6 (statement -> input_stmt .)
    for             reduce using rule 6 (statement -> input_stmt .)
    while           reduce using rule 6 (statement -> input_stmt .)
    INTEGER         reduce using rule 6 (statement -> input_stmt .)
    STRING          reduce using rule 6 (statement -> input_stmt .)
    FLOAT           reduce using rule 6 (statement -> input_stmt .)
    $end            reduce using rule 6 (statement -> input_stmt .)
    DEDENT          reduce using rule 6 (statement -> input_stmt .)
    elif            reduce using rule 6 (statement -> input_stmt .)
    else            reduce using rule 6 (statement -> input_stmt .)


state 6

    (7) statement -> print_stmt .

    NEWLINE         reduce using rule 7 (statement -> print_stmt .)
    ID              reduce using rule 7 (statement -> print_stmt .)
    LPAREN          reduce using rule 7 (statement -> print_stmt .)
    print           reduce using rule 7 (statement -> print_stmt .)
    if              reduce using rule 7 (statement -> print_stmt .)
    for             reduce using rule 7 (statement -> print_stmt .)
    while           reduce using rule 7 (statement -> print_stmt .)
    INTEGER         reduce using rule 7 (statement -> print_stmt .)
    STRING          reduce using rule 7 (statement -> print_stmt .)
    FLOAT           reduce using rule 7 (statement -> print_stmt .)
    $end            reduce using rule 7 (statement -> print_stmt .)
    DEDENT          reduce using rule 7 (statement -> print_stmt .)
    elif            reduce using rule 7 (statement -> print_stmt .)
    else            reduce using rule 7 (statement -> print_stmt .)


state 7

    (8) statement -> if_stmt .

    NEWLINE         reduce using rule 8 (statement -> if_stmt .)
    ID              reduce using rule 8 (statement -> if_stmt .)
    LPAREN          reduce using rule 8 (statement -> if_stmt .)
    print           reduce using rule 8 (statement -> if_stmt .)
    if              reduce using rule 8 (statement -> if_stmt .)
    for             reduce using rule 8 (statement -> if_stmt .)
    while           reduce using rule 8 (statement -> if_stmt .)
    INTEGER         reduce using rule 8 (statement -> if_stmt .)
    STRING          reduce using rule 8 (statement -> if_stmt .)
    FLOAT           reduce using rule 8 (statement -> if_stmt .)
    $end            reduce using rule 8 (statement -> if_stmt .)
    DEDENT          reduce using rule 8 (statement -> if_stmt .)
    elif            reduce using rule 8 (statement -> if_stmt .)
    else            reduce using rule 8 (statement -> if_stmt .)


state 8

    (9) statement -> for_stmt .

    NEWLINE         reduce using rule 9 (statement -> for_stmt .)
    ID              reduce using rule 9 (statement -> for_stmt .)
    LPAREN          reduce using rule 9 (statement -> for_stmt .)
    print           reduce using rule 9 (statement -> for_stmt .)
    if              reduce using rule 9 (statement -> for_stmt .)
    for             reduce using rule 9 (statement -> for_stmt .)
    while           reduce using rule 9 (statement -> for_stmt .)
    INTEGER         reduce using rule 9 (statement -> for_stmt .)
    STRING          reduce using rule 9 (statement -> for_stmt .)
    FLOAT           reduce using rule 9 (statement -> for_stmt .)
    $end            reduce using rule 9 (statement -> for_stmt .)
    DEDENT          reduce using rule 9 (statement -> for_stmt .)
    elif            reduce using rule 9 (statement -> for_stmt .)
    else            reduce using rule 9 (statement -> for_stmt .)


state 9

    (10) statement -> while_stmt .

    NEWLINE         reduce using rule 10 (statement -> while_stmt .)
    ID              reduce using rule 10 (statement -> while_stmt .)
    LPAREN          reduce using rule 10 (statement -> while_stmt .)
    print           reduce using rule 10 (statement -> while_stmt .)
    if              reduce using rule 10 (statement -> while_stmt .)
    for             reduce using rule 10 (statement -> while_stmt .)
    while           reduce using rule 10 (statement -> while_stmt .)
    INTEGER         reduce using rule 10 (statement -> while_stmt .)
    STRING          reduce using rule 10 (statement -> while_stmt .)
    FLOAT           reduce using rule 10 (statement -> while_stmt .)
    $end            reduce using rule 10 (statement -> while_stmt .)
    DEDENT          reduce using rule 10 (statement -> while_stmt .)
    elif            reduce using rule 10 (statement -> while_stmt .)
    else            reduce using rule 10 (statement -> while_stmt .)


state 10

    (11) assign -> ID . EQUALS expr
    (23) input_stmt -> ID . EQUALS input LPAREN RPAREN
    (20) factor -> ID .

    EQUALS          shift and go to state 25
    TIMES           reduce using rule 20 (factor -> ID .)
    DIVIDE          reduce using rule 20 (factor -> ID .)
    PLUS            reduce using rule 20 (factor -> ID .)
    MINUS           reduce using rule 20 (factor -> ID .)
    NEWLINE         reduce using rule 20 (factor -> ID .)
    ID              reduce using rule 20 (factor -> ID .)
    LPAREN          reduce using rule 20 (factor -> ID .)
    print           reduce using rule 20 (factor -> ID .)
    if              reduce using rule 20 (factor -> ID .)
    for             reduce using rule 20 (factor -> ID .)
    while           reduce using rule 20 (factor -> ID .)
    INTEGER         reduce using rule 20 (factor -> ID .)
    STRING          reduce using rule 20 (factor -> ID .)
    FLOAT           reduce using rule 20 (factor -> ID .)
    $end            reduce using rule 20 (factor -> ID .)
    DEDENT          reduce using rule 20 (factor -> ID .)
    elif            reduce using rule 20 (factor -> ID .)
    else            reduce using rule 20 (factor -> ID .)


state 11

    (14) expr -> term .
    (16) term -> term . TIMES factor
    (17) term -> term . DIVIDE factor

    PLUS            reduce using rule 14 (expr -> term .)
    MINUS           reduce using rule 14 (expr -> term .)
    NEWLINE         reduce using rule 14 (expr -> term .)
    ID              reduce using rule 14 (expr -> term .)
    LPAREN          reduce using rule 14 (expr -> term .)
    print           reduce using rule 14 (expr -> term .)
    if              reduce using rule 14 (expr -> term .)
    for             reduce using rule 14 (expr -> term .)
    while           reduce using rule 14 (expr -> term .)
    INTEGER         reduce using rule 14 (expr -> term .)
    STRING          reduce using rule 14 (expr -> term .)
    FLOAT           reduce using rule 14 (expr -> term .)
    $end            reduce using rule 14 (expr -> term .)
    DEDENT          reduce using rule 14 (expr -> term .)
    elif            reduce using rule 14 (expr -> term .)
    else            reduce using rule 14 (expr -> term .)
    RPAREN          reduce using rule 14 (expr -> term .)
    GREATER         reduce using rule 14 (expr -> term .)
    LESS            reduce using rule 14 (expr -> term .)
    EQUALTO         reduce using rule 14 (expr -> term .)
    NOTEQUALTO      reduce using rule 14 (expr -> term .)
    COLON           reduce using rule 14 (expr -> term .)
    COMMA           reduce using rule 14 (expr -> term .)
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27


state 12

    (15) expr -> LPAREN . expr RPAREN
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 28
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 13

    (24) print_stmt -> print . LPAREN expr RPAREN

    LPAREN          shift and go to state 30


state 14

    (29) if_stmt -> if . comp_op COLON block
    (30) if_stmt -> if . comp_op COLON block elif_stmt
    (31) if_stmt -> if . comp_op COLON block else_block
    (25) comp_op -> . expr GREATER expr
    (26) comp_op -> . expr LESS expr
    (27) comp_op -> . expr EQUALTO expr
    (28) comp_op -> . expr NOTEQUALTO expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    comp_op                        shift and go to state 31
    expr                           shift and go to state 32
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 15

    (38) for_stmt -> for . ID in range target_list COLON block

    ID              shift and go to state 33


state 16

    (41) while_stmt -> while . comp_op COLON block
    (25) comp_op -> . expr GREATER expr
    (26) comp_op -> . expr LESS expr
    (27) comp_op -> . expr EQUALTO expr
    (28) comp_op -> . expr NOTEQUALTO expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    comp_op                        shift and go to state 34
    expr                           shift and go to state 32
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 17

    (18) term -> factor .

    TIMES           reduce using rule 18 (term -> factor .)
    DIVIDE          reduce using rule 18 (term -> factor .)
    PLUS            reduce using rule 18 (term -> factor .)
    MINUS           reduce using rule 18 (term -> factor .)
    NEWLINE         reduce using rule 18 (term -> factor .)
    ID              reduce using rule 18 (term -> factor .)
    LPAREN          reduce using rule 18 (term -> factor .)
    print           reduce using rule 18 (term -> factor .)
    if              reduce using rule 18 (term -> factor .)
    for             reduce using rule 18 (term -> factor .)
    while           reduce using rule 18 (term -> factor .)
    INTEGER         reduce using rule 18 (term -> factor .)
    STRING          reduce using rule 18 (term -> factor .)
    FLOAT           reduce using rule 18 (term -> factor .)
    $end            reduce using rule 18 (term -> factor .)
    DEDENT          reduce using rule 18 (term -> factor .)
    elif            reduce using rule 18 (term -> factor .)
    else            reduce using rule 18 (term -> factor .)
    RPAREN          reduce using rule 18 (term -> factor .)
    GREATER         reduce using rule 18 (term -> factor .)
    LESS            reduce using rule 18 (term -> factor .)
    EQUALTO         reduce using rule 18 (term -> factor .)
    NOTEQUALTO      reduce using rule 18 (term -> factor .)
    COLON           reduce using rule 18 (term -> factor .)
    COMMA           reduce using rule 18 (term -> factor .)


state 18

    (19) factor -> INTEGER .

    TIMES           reduce using rule 19 (factor -> INTEGER .)
    DIVIDE          reduce using rule 19 (factor -> INTEGER .)
    PLUS            reduce using rule 19 (factor -> INTEGER .)
    MINUS           reduce using rule 19 (factor -> INTEGER .)
    NEWLINE         reduce using rule 19 (factor -> INTEGER .)
    ID              reduce using rule 19 (factor -> INTEGER .)
    LPAREN          reduce using rule 19 (factor -> INTEGER .)
    print           reduce using rule 19 (factor -> INTEGER .)
    if              reduce using rule 19 (factor -> INTEGER .)
    for             reduce using rule 19 (factor -> INTEGER .)
    while           reduce using rule 19 (factor -> INTEGER .)
    INTEGER         reduce using rule 19 (factor -> INTEGER .)
    STRING          reduce using rule 19 (factor -> INTEGER .)
    FLOAT           reduce using rule 19 (factor -> INTEGER .)
    $end            reduce using rule 19 (factor -> INTEGER .)
    DEDENT          reduce using rule 19 (factor -> INTEGER .)
    elif            reduce using rule 19 (factor -> INTEGER .)
    else            reduce using rule 19 (factor -> INTEGER .)
    RPAREN          reduce using rule 19 (factor -> INTEGER .)
    GREATER         reduce using rule 19 (factor -> INTEGER .)
    LESS            reduce using rule 19 (factor -> INTEGER .)
    EQUALTO         reduce using rule 19 (factor -> INTEGER .)
    NOTEQUALTO      reduce using rule 19 (factor -> INTEGER .)
    COLON           reduce using rule 19 (factor -> INTEGER .)
    COMMA           reduce using rule 19 (factor -> INTEGER .)


state 19

    (21) factor -> STRING .

    TIMES           reduce using rule 21 (factor -> STRING .)
    DIVIDE          reduce using rule 21 (factor -> STRING .)
    PLUS            reduce using rule 21 (factor -> STRING .)
    MINUS           reduce using rule 21 (factor -> STRING .)
    NEWLINE         reduce using rule 21 (factor -> STRING .)
    ID              reduce using rule 21 (factor -> STRING .)
    LPAREN          reduce using rule 21 (factor -> STRING .)
    print           reduce using rule 21 (factor -> STRING .)
    if              reduce using rule 21 (factor -> STRING .)
    for             reduce using rule 21 (factor -> STRING .)
    while           reduce using rule 21 (factor -> STRING .)
    INTEGER         reduce using rule 21 (factor -> STRING .)
    STRING          reduce using rule 21 (factor -> STRING .)
    FLOAT           reduce using rule 21 (factor -> STRING .)
    $end            reduce using rule 21 (factor -> STRING .)
    DEDENT          reduce using rule 21 (factor -> STRING .)
    elif            reduce using rule 21 (factor -> STRING .)
    else            reduce using rule 21 (factor -> STRING .)
    RPAREN          reduce using rule 21 (factor -> STRING .)
    GREATER         reduce using rule 21 (factor -> STRING .)
    LESS            reduce using rule 21 (factor -> STRING .)
    EQUALTO         reduce using rule 21 (factor -> STRING .)
    NOTEQUALTO      reduce using rule 21 (factor -> STRING .)
    COLON           reduce using rule 21 (factor -> STRING .)
    COMMA           reduce using rule 21 (factor -> STRING .)


state 20

    (22) factor -> FLOAT .

    TIMES           reduce using rule 22 (factor -> FLOAT .)
    DIVIDE          reduce using rule 22 (factor -> FLOAT .)
    PLUS            reduce using rule 22 (factor -> FLOAT .)
    MINUS           reduce using rule 22 (factor -> FLOAT .)
    NEWLINE         reduce using rule 22 (factor -> FLOAT .)
    ID              reduce using rule 22 (factor -> FLOAT .)
    LPAREN          reduce using rule 22 (factor -> FLOAT .)
    print           reduce using rule 22 (factor -> FLOAT .)
    if              reduce using rule 22 (factor -> FLOAT .)
    for             reduce using rule 22 (factor -> FLOAT .)
    while           reduce using rule 22 (factor -> FLOAT .)
    INTEGER         reduce using rule 22 (factor -> FLOAT .)
    STRING          reduce using rule 22 (factor -> FLOAT .)
    FLOAT           reduce using rule 22 (factor -> FLOAT .)
    $end            reduce using rule 22 (factor -> FLOAT .)
    DEDENT          reduce using rule 22 (factor -> FLOAT .)
    elif            reduce using rule 22 (factor -> FLOAT .)
    else            reduce using rule 22 (factor -> FLOAT .)
    RPAREN          reduce using rule 22 (factor -> FLOAT .)
    GREATER         reduce using rule 22 (factor -> FLOAT .)
    LESS            reduce using rule 22 (factor -> FLOAT .)
    EQUALTO         reduce using rule 22 (factor -> FLOAT .)
    NOTEQUALTO      reduce using rule 22 (factor -> FLOAT .)
    COLON           reduce using rule 22 (factor -> FLOAT .)
    COMMA           reduce using rule 22 (factor -> FLOAT .)


state 21

    (2) statements -> statement NEWLINE . statements
    (1) statements -> . statement
    (2) statements -> . statement NEWLINE statements
    (3) statements -> . statement statements
    (4) statement -> . assign
    (5) statement -> . expr
    (6) statement -> . input_stmt
    (7) statement -> . print_stmt
    (8) statement -> . if_stmt
    (9) statement -> . for_stmt
    (10) statement -> . while_stmt
    (11) assign -> . ID EQUALS expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (23) input_stmt -> . ID EQUALS input LPAREN RPAREN
    (24) print_stmt -> . print LPAREN expr RPAREN
    (29) if_stmt -> . if comp_op COLON block
    (30) if_stmt -> . if comp_op COLON block elif_stmt
    (31) if_stmt -> . if comp_op COLON block else_block
    (38) for_stmt -> . for ID in range target_list COLON block
    (41) while_stmt -> . while comp_op COLON block
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    ID              shift and go to state 10
    LPAREN          shift and go to state 12
    print           shift and go to state 13
    if              shift and go to state 14
    for             shift and go to state 15
    while           shift and go to state 16
    INTEGER         shift and go to state 18
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    statement                      shift and go to state 2
    statements                     shift and go to state 35
    assign                         shift and go to state 3
    expr                           shift and go to state 4
    input_stmt                     shift and go to state 5
    print_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7
    for_stmt                       shift and go to state 8
    while_stmt                     shift and go to state 9
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 22

    (3) statements -> statement statements .

    $end            reduce using rule 3 (statements -> statement statements .)
    DEDENT          reduce using rule 3 (statements -> statement statements .)
    elif            reduce using rule 3 (statements -> statement statements .)
    else            reduce using rule 3 (statements -> statement statements .)
    NEWLINE         reduce using rule 3 (statements -> statement statements .)
    ID              reduce using rule 3 (statements -> statement statements .)
    LPAREN          reduce using rule 3 (statements -> statement statements .)
    print           reduce using rule 3 (statements -> statement statements .)
    if              reduce using rule 3 (statements -> statement statements .)
    for             reduce using rule 3 (statements -> statement statements .)
    while           reduce using rule 3 (statements -> statement statements .)
    INTEGER         reduce using rule 3 (statements -> statement statements .)
    STRING          reduce using rule 3 (statements -> statement statements .)
    FLOAT           reduce using rule 3 (statements -> statement statements .)


state 23

    (12) expr -> expr PLUS . term
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    term                           shift and go to state 36
    factor                         shift and go to state 17

state 24

    (13) expr -> expr MINUS . term
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    term                           shift and go to state 37
    factor                         shift and go to state 17

state 25

    (11) assign -> ID EQUALS . expr
    (23) input_stmt -> ID EQUALS . input LPAREN RPAREN
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    input           shift and go to state 39
    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 38
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 26

    (16) term -> term TIMES . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    factor                         shift and go to state 40

state 27

    (17) term -> term DIVIDE . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    factor                         shift and go to state 41

state 28

    (15) expr -> LPAREN expr . RPAREN
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    RPAREN          shift and go to state 42
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 29

    (20) factor -> ID .

    TIMES           reduce using rule 20 (factor -> ID .)
    DIVIDE          reduce using rule 20 (factor -> ID .)
    RPAREN          reduce using rule 20 (factor -> ID .)
    PLUS            reduce using rule 20 (factor -> ID .)
    MINUS           reduce using rule 20 (factor -> ID .)
    GREATER         reduce using rule 20 (factor -> ID .)
    LESS            reduce using rule 20 (factor -> ID .)
    EQUALTO         reduce using rule 20 (factor -> ID .)
    NOTEQUALTO      reduce using rule 20 (factor -> ID .)
    NEWLINE         reduce using rule 20 (factor -> ID .)
    ID              reduce using rule 20 (factor -> ID .)
    LPAREN          reduce using rule 20 (factor -> ID .)
    print           reduce using rule 20 (factor -> ID .)
    if              reduce using rule 20 (factor -> ID .)
    for             reduce using rule 20 (factor -> ID .)
    while           reduce using rule 20 (factor -> ID .)
    INTEGER         reduce using rule 20 (factor -> ID .)
    STRING          reduce using rule 20 (factor -> ID .)
    FLOAT           reduce using rule 20 (factor -> ID .)
    $end            reduce using rule 20 (factor -> ID .)
    DEDENT          reduce using rule 20 (factor -> ID .)
    elif            reduce using rule 20 (factor -> ID .)
    else            reduce using rule 20 (factor -> ID .)
    COLON           reduce using rule 20 (factor -> ID .)
    COMMA           reduce using rule 20 (factor -> ID .)


state 30

    (24) print_stmt -> print LPAREN . expr RPAREN
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 43
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 31

    (29) if_stmt -> if comp_op . COLON block
    (30) if_stmt -> if comp_op . COLON block elif_stmt
    (31) if_stmt -> if comp_op . COLON block else_block

    COLON           shift and go to state 44


state 32

    (25) comp_op -> expr . GREATER expr
    (26) comp_op -> expr . LESS expr
    (27) comp_op -> expr . EQUALTO expr
    (28) comp_op -> expr . NOTEQUALTO expr
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    GREATER         shift and go to state 45
    LESS            shift and go to state 46
    EQUALTO         shift and go to state 47
    NOTEQUALTO      shift and go to state 48
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 33

    (38) for_stmt -> for ID . in range target_list COLON block

    in              shift and go to state 49


state 34

    (41) while_stmt -> while comp_op . COLON block

    COLON           shift and go to state 50


state 35

    (2) statements -> statement NEWLINE statements .

    $end            reduce using rule 2 (statements -> statement NEWLINE statements .)
    DEDENT          reduce using rule 2 (statements -> statement NEWLINE statements .)
    elif            reduce using rule 2 (statements -> statement NEWLINE statements .)
    else            reduce using rule 2 (statements -> statement NEWLINE statements .)
    NEWLINE         reduce using rule 2 (statements -> statement NEWLINE statements .)
    ID              reduce using rule 2 (statements -> statement NEWLINE statements .)
    LPAREN          reduce using rule 2 (statements -> statement NEWLINE statements .)
    print           reduce using rule 2 (statements -> statement NEWLINE statements .)
    if              reduce using rule 2 (statements -> statement NEWLINE statements .)
    for             reduce using rule 2 (statements -> statement NEWLINE statements .)
    while           reduce using rule 2 (statements -> statement NEWLINE statements .)
    INTEGER         reduce using rule 2 (statements -> statement NEWLINE statements .)
    STRING          reduce using rule 2 (statements -> statement NEWLINE statements .)
    FLOAT           reduce using rule 2 (statements -> statement NEWLINE statements .)


state 36

    (12) expr -> expr PLUS term .
    (16) term -> term . TIMES factor
    (17) term -> term . DIVIDE factor

    PLUS            reduce using rule 12 (expr -> expr PLUS term .)
    MINUS           reduce using rule 12 (expr -> expr PLUS term .)
    NEWLINE         reduce using rule 12 (expr -> expr PLUS term .)
    ID              reduce using rule 12 (expr -> expr PLUS term .)
    LPAREN          reduce using rule 12 (expr -> expr PLUS term .)
    print           reduce using rule 12 (expr -> expr PLUS term .)
    if              reduce using rule 12 (expr -> expr PLUS term .)
    for             reduce using rule 12 (expr -> expr PLUS term .)
    while           reduce using rule 12 (expr -> expr PLUS term .)
    INTEGER         reduce using rule 12 (expr -> expr PLUS term .)
    STRING          reduce using rule 12 (expr -> expr PLUS term .)
    FLOAT           reduce using rule 12 (expr -> expr PLUS term .)
    $end            reduce using rule 12 (expr -> expr PLUS term .)
    DEDENT          reduce using rule 12 (expr -> expr PLUS term .)
    elif            reduce using rule 12 (expr -> expr PLUS term .)
    else            reduce using rule 12 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 12 (expr -> expr PLUS term .)
    GREATER         reduce using rule 12 (expr -> expr PLUS term .)
    LESS            reduce using rule 12 (expr -> expr PLUS term .)
    EQUALTO         reduce using rule 12 (expr -> expr PLUS term .)
    NOTEQUALTO      reduce using rule 12 (expr -> expr PLUS term .)
    COLON           reduce using rule 12 (expr -> expr PLUS term .)
    COMMA           reduce using rule 12 (expr -> expr PLUS term .)
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27


state 37

    (13) expr -> expr MINUS term .
    (16) term -> term . TIMES factor
    (17) term -> term . DIVIDE factor

    PLUS            reduce using rule 13 (expr -> expr MINUS term .)
    MINUS           reduce using rule 13 (expr -> expr MINUS term .)
    NEWLINE         reduce using rule 13 (expr -> expr MINUS term .)
    ID              reduce using rule 13 (expr -> expr MINUS term .)
    LPAREN          reduce using rule 13 (expr -> expr MINUS term .)
    print           reduce using rule 13 (expr -> expr MINUS term .)
    if              reduce using rule 13 (expr -> expr MINUS term .)
    for             reduce using rule 13 (expr -> expr MINUS term .)
    while           reduce using rule 13 (expr -> expr MINUS term .)
    INTEGER         reduce using rule 13 (expr -> expr MINUS term .)
    STRING          reduce using rule 13 (expr -> expr MINUS term .)
    FLOAT           reduce using rule 13 (expr -> expr MINUS term .)
    $end            reduce using rule 13 (expr -> expr MINUS term .)
    DEDENT          reduce using rule 13 (expr -> expr MINUS term .)
    elif            reduce using rule 13 (expr -> expr MINUS term .)
    else            reduce using rule 13 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 13 (expr -> expr MINUS term .)
    GREATER         reduce using rule 13 (expr -> expr MINUS term .)
    LESS            reduce using rule 13 (expr -> expr MINUS term .)
    EQUALTO         reduce using rule 13 (expr -> expr MINUS term .)
    NOTEQUALTO      reduce using rule 13 (expr -> expr MINUS term .)
    COLON           reduce using rule 13 (expr -> expr MINUS term .)
    COMMA           reduce using rule 13 (expr -> expr MINUS term .)
    TIMES           shift and go to state 26
    DIVIDE          shift and go to state 27


state 38

    (11) assign -> ID EQUALS expr .
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    NEWLINE         reduce using rule 11 (assign -> ID EQUALS expr .)
    ID              reduce using rule 11 (assign -> ID EQUALS expr .)
    LPAREN          reduce using rule 11 (assign -> ID EQUALS expr .)
    print           reduce using rule 11 (assign -> ID EQUALS expr .)
    if              reduce using rule 11 (assign -> ID EQUALS expr .)
    for             reduce using rule 11 (assign -> ID EQUALS expr .)
    while           reduce using rule 11 (assign -> ID EQUALS expr .)
    INTEGER         reduce using rule 11 (assign -> ID EQUALS expr .)
    STRING          reduce using rule 11 (assign -> ID EQUALS expr .)
    FLOAT           reduce using rule 11 (assign -> ID EQUALS expr .)
    $end            reduce using rule 11 (assign -> ID EQUALS expr .)
    DEDENT          reduce using rule 11 (assign -> ID EQUALS expr .)
    elif            reduce using rule 11 (assign -> ID EQUALS expr .)
    else            reduce using rule 11 (assign -> ID EQUALS expr .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 39

    (23) input_stmt -> ID EQUALS input . LPAREN RPAREN

    LPAREN          shift and go to state 51


state 40

    (16) term -> term TIMES factor .

    TIMES           reduce using rule 16 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 16 (term -> term TIMES factor .)
    PLUS            reduce using rule 16 (term -> term TIMES factor .)
    MINUS           reduce using rule 16 (term -> term TIMES factor .)
    NEWLINE         reduce using rule 16 (term -> term TIMES factor .)
    ID              reduce using rule 16 (term -> term TIMES factor .)
    LPAREN          reduce using rule 16 (term -> term TIMES factor .)
    print           reduce using rule 16 (term -> term TIMES factor .)
    if              reduce using rule 16 (term -> term TIMES factor .)
    for             reduce using rule 16 (term -> term TIMES factor .)
    while           reduce using rule 16 (term -> term TIMES factor .)
    INTEGER         reduce using rule 16 (term -> term TIMES factor .)
    STRING          reduce using rule 16 (term -> term TIMES factor .)
    FLOAT           reduce using rule 16 (term -> term TIMES factor .)
    $end            reduce using rule 16 (term -> term TIMES factor .)
    DEDENT          reduce using rule 16 (term -> term TIMES factor .)
    elif            reduce using rule 16 (term -> term TIMES factor .)
    else            reduce using rule 16 (term -> term TIMES factor .)
    RPAREN          reduce using rule 16 (term -> term TIMES factor .)
    GREATER         reduce using rule 16 (term -> term TIMES factor .)
    LESS            reduce using rule 16 (term -> term TIMES factor .)
    EQUALTO         reduce using rule 16 (term -> term TIMES factor .)
    NOTEQUALTO      reduce using rule 16 (term -> term TIMES factor .)
    COLON           reduce using rule 16 (term -> term TIMES factor .)
    COMMA           reduce using rule 16 (term -> term TIMES factor .)


state 41

    (17) term -> term DIVIDE factor .

    TIMES           reduce using rule 17 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 17 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 17 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 17 (term -> term DIVIDE factor .)
    NEWLINE         reduce using rule 17 (term -> term DIVIDE factor .)
    ID              reduce using rule 17 (term -> term DIVIDE factor .)
    LPAREN          reduce using rule 17 (term -> term DIVIDE factor .)
    print           reduce using rule 17 (term -> term DIVIDE factor .)
    if              reduce using rule 17 (term -> term DIVIDE factor .)
    for             reduce using rule 17 (term -> term DIVIDE factor .)
    while           reduce using rule 17 (term -> term DIVIDE factor .)
    INTEGER         reduce using rule 17 (term -> term DIVIDE factor .)
    STRING          reduce using rule 17 (term -> term DIVIDE factor .)
    FLOAT           reduce using rule 17 (term -> term DIVIDE factor .)
    $end            reduce using rule 17 (term -> term DIVIDE factor .)
    DEDENT          reduce using rule 17 (term -> term DIVIDE factor .)
    elif            reduce using rule 17 (term -> term DIVIDE factor .)
    else            reduce using rule 17 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 17 (term -> term DIVIDE factor .)
    GREATER         reduce using rule 17 (term -> term DIVIDE factor .)
    LESS            reduce using rule 17 (term -> term DIVIDE factor .)
    EQUALTO         reduce using rule 17 (term -> term DIVIDE factor .)
    NOTEQUALTO      reduce using rule 17 (term -> term DIVIDE factor .)
    COLON           reduce using rule 17 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 17 (term -> term DIVIDE factor .)


state 42

    (15) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    NEWLINE         reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    print           reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    if              reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    for             reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    while           reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    INTEGER         reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    STRING          reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    FLOAT           reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    DEDENT          reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    elif            reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    else            reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    LESS            reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    EQUALTO         reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    NOTEQUALTO      reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 15 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 15 (expr -> LPAREN expr RPAREN .)


state 43

    (24) print_stmt -> print LPAREN expr . RPAREN
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    RPAREN          shift and go to state 52
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 44

    (29) if_stmt -> if comp_op COLON . block
    (30) if_stmt -> if comp_op COLON . block elif_stmt
    (31) if_stmt -> if comp_op COLON . block else_block
    (36) block -> . INDENT statements
    (37) block -> . INDENT statements DEDENT

    INDENT          shift and go to state 54

    block                          shift and go to state 53

state 45

    (25) comp_op -> expr GREATER . expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 55
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 46

    (26) comp_op -> expr LESS . expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 56
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 47

    (27) comp_op -> expr EQUALTO . expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 57
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 48

    (28) comp_op -> expr NOTEQUALTO . expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 58
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 49

    (38) for_stmt -> for ID in . range target_list COLON block

    range           shift and go to state 59


state 50

    (41) while_stmt -> while comp_op COLON . block
    (36) block -> . INDENT statements
    (37) block -> . INDENT statements DEDENT

    INDENT          shift and go to state 54

    block                          shift and go to state 60

state 51

    (23) input_stmt -> ID EQUALS input LPAREN . RPAREN

    RPAREN          shift and go to state 61


state 52

    (24) print_stmt -> print LPAREN expr RPAREN .

    NEWLINE         reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    ID              reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    LPAREN          reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    print           reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    if              reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    for             reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    while           reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    INTEGER         reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    STRING          reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    FLOAT           reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    $end            reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    DEDENT          reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    elif            reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)
    else            reduce using rule 24 (print_stmt -> print LPAREN expr RPAREN .)


state 53

    (29) if_stmt -> if comp_op COLON block .
    (30) if_stmt -> if comp_op COLON block . elif_stmt
    (31) if_stmt -> if comp_op COLON block . else_block
    (32) elif_stmt -> . elif comp_op COLON block
    (33) elif_stmt -> . elif comp_op COLON block elif_stmt
    (34) elif_stmt -> . elif comp_op COLON block else_block
    (35) else_block -> . else COLON block

  ! shift/reduce conflict for elif resolved as shift
  ! shift/reduce conflict for else resolved as shift
    NEWLINE         reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    ID              reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    LPAREN          reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    print           reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    if              reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    for             reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    while           reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    INTEGER         reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    STRING          reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    FLOAT           reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    $end            reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    DEDENT          reduce using rule 29 (if_stmt -> if comp_op COLON block .)
    elif            shift and go to state 64
    else            shift and go to state 65

  ! elif            [ reduce using rule 29 (if_stmt -> if comp_op COLON block .) ]
  ! else            [ reduce using rule 29 (if_stmt -> if comp_op COLON block .) ]

    elif_stmt                      shift and go to state 62
    else_block                     shift and go to state 63

state 54

    (36) block -> INDENT . statements
    (37) block -> INDENT . statements DEDENT
    (1) statements -> . statement
    (2) statements -> . statement NEWLINE statements
    (3) statements -> . statement statements
    (4) statement -> . assign
    (5) statement -> . expr
    (6) statement -> . input_stmt
    (7) statement -> . print_stmt
    (8) statement -> . if_stmt
    (9) statement -> . for_stmt
    (10) statement -> . while_stmt
    (11) assign -> . ID EQUALS expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (23) input_stmt -> . ID EQUALS input LPAREN RPAREN
    (24) print_stmt -> . print LPAREN expr RPAREN
    (29) if_stmt -> . if comp_op COLON block
    (30) if_stmt -> . if comp_op COLON block elif_stmt
    (31) if_stmt -> . if comp_op COLON block else_block
    (38) for_stmt -> . for ID in range target_list COLON block
    (41) while_stmt -> . while comp_op COLON block
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    ID              shift and go to state 10
    LPAREN          shift and go to state 12
    print           shift and go to state 13
    if              shift and go to state 14
    for             shift and go to state 15
    while           shift and go to state 16
    INTEGER         shift and go to state 18
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    statements                     shift and go to state 66
    statement                      shift and go to state 2
    assign                         shift and go to state 3
    expr                           shift and go to state 4
    input_stmt                     shift and go to state 5
    print_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7
    for_stmt                       shift and go to state 8
    while_stmt                     shift and go to state 9
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 55

    (25) comp_op -> expr GREATER expr .
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    COLON           reduce using rule 25 (comp_op -> expr GREATER expr .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 56

    (26) comp_op -> expr LESS expr .
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    COLON           reduce using rule 26 (comp_op -> expr LESS expr .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 57

    (27) comp_op -> expr EQUALTO expr .
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    COLON           reduce using rule 27 (comp_op -> expr EQUALTO expr .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 58

    (28) comp_op -> expr NOTEQUALTO expr .
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    COLON           reduce using rule 28 (comp_op -> expr NOTEQUALTO expr .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 59

    (38) for_stmt -> for ID in range . target_list COLON block
    (39) target_list -> . expr
    (40) target_list -> . LPAREN expr COMMA expr RPAREN
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 69
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    target_list                    shift and go to state 67
    expr                           shift and go to state 68
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 60

    (41) while_stmt -> while comp_op COLON block .

    NEWLINE         reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    ID              reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    LPAREN          reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    print           reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    if              reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    for             reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    while           reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    INTEGER         reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    STRING          reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    FLOAT           reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    $end            reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    DEDENT          reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    elif            reduce using rule 41 (while_stmt -> while comp_op COLON block .)
    else            reduce using rule 41 (while_stmt -> while comp_op COLON block .)


state 61

    (23) input_stmt -> ID EQUALS input LPAREN RPAREN .

    NEWLINE         reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    ID              reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    LPAREN          reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    print           reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    if              reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    for             reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    while           reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    INTEGER         reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    STRING          reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    FLOAT           reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    $end            reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    DEDENT          reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    elif            reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)
    else            reduce using rule 23 (input_stmt -> ID EQUALS input LPAREN RPAREN .)


state 62

    (30) if_stmt -> if comp_op COLON block elif_stmt .

    NEWLINE         reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    ID              reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    LPAREN          reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    print           reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    if              reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    for             reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    while           reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    INTEGER         reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    STRING          reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    FLOAT           reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    $end            reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    DEDENT          reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    elif            reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)
    else            reduce using rule 30 (if_stmt -> if comp_op COLON block elif_stmt .)


state 63

    (31) if_stmt -> if comp_op COLON block else_block .

    NEWLINE         reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    ID              reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    LPAREN          reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    print           reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    if              reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    for             reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    while           reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    INTEGER         reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    STRING          reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    FLOAT           reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    $end            reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    DEDENT          reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    elif            reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)
    else            reduce using rule 31 (if_stmt -> if comp_op COLON block else_block .)


state 64

    (32) elif_stmt -> elif . comp_op COLON block
    (33) elif_stmt -> elif . comp_op COLON block elif_stmt
    (34) elif_stmt -> elif . comp_op COLON block else_block
    (25) comp_op -> . expr GREATER expr
    (26) comp_op -> . expr LESS expr
    (27) comp_op -> . expr EQUALTO expr
    (28) comp_op -> . expr NOTEQUALTO expr
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    comp_op                        shift and go to state 70
    expr                           shift and go to state 32
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 65

    (35) else_block -> else . COLON block

    COLON           shift and go to state 71


state 66

    (36) block -> INDENT statements .
    (37) block -> INDENT statements . DEDENT

  ! shift/reduce conflict for DEDENT resolved as shift
    $end            reduce using rule 36 (block -> INDENT statements .)
    elif            reduce using rule 36 (block -> INDENT statements .)
    else            reduce using rule 36 (block -> INDENT statements .)
    NEWLINE         reduce using rule 36 (block -> INDENT statements .)
    ID              reduce using rule 36 (block -> INDENT statements .)
    LPAREN          reduce using rule 36 (block -> INDENT statements .)
    print           reduce using rule 36 (block -> INDENT statements .)
    if              reduce using rule 36 (block -> INDENT statements .)
    for             reduce using rule 36 (block -> INDENT statements .)
    while           reduce using rule 36 (block -> INDENT statements .)
    INTEGER         reduce using rule 36 (block -> INDENT statements .)
    STRING          reduce using rule 36 (block -> INDENT statements .)
    FLOAT           reduce using rule 36 (block -> INDENT statements .)
    DEDENT          shift and go to state 72

  ! DEDENT          [ reduce using rule 36 (block -> INDENT statements .) ]


state 67

    (38) for_stmt -> for ID in range target_list . COLON block

    COLON           shift and go to state 73


state 68

    (39) target_list -> expr .
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    COLON           reduce using rule 39 (target_list -> expr .)
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 69

    (40) target_list -> LPAREN . expr COMMA expr RPAREN
    (15) expr -> LPAREN . expr RPAREN
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 74
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 70

    (32) elif_stmt -> elif comp_op . COLON block
    (33) elif_stmt -> elif comp_op . COLON block elif_stmt
    (34) elif_stmt -> elif comp_op . COLON block else_block

    COLON           shift and go to state 75


state 71

    (35) else_block -> else COLON . block
    (36) block -> . INDENT statements
    (37) block -> . INDENT statements DEDENT

    INDENT          shift and go to state 54

    block                          shift and go to state 76

state 72

    (37) block -> INDENT statements DEDENT .

    $end            reduce using rule 37 (block -> INDENT statements DEDENT .)
    DEDENT          reduce using rule 37 (block -> INDENT statements DEDENT .)
    elif            reduce using rule 37 (block -> INDENT statements DEDENT .)
    else            reduce using rule 37 (block -> INDENT statements DEDENT .)
    NEWLINE         reduce using rule 37 (block -> INDENT statements DEDENT .)
    ID              reduce using rule 37 (block -> INDENT statements DEDENT .)
    LPAREN          reduce using rule 37 (block -> INDENT statements DEDENT .)
    print           reduce using rule 37 (block -> INDENT statements DEDENT .)
    if              reduce using rule 37 (block -> INDENT statements DEDENT .)
    for             reduce using rule 37 (block -> INDENT statements DEDENT .)
    while           reduce using rule 37 (block -> INDENT statements DEDENT .)
    INTEGER         reduce using rule 37 (block -> INDENT statements DEDENT .)
    STRING          reduce using rule 37 (block -> INDENT statements DEDENT .)
    FLOAT           reduce using rule 37 (block -> INDENT statements DEDENT .)


state 73

    (38) for_stmt -> for ID in range target_list COLON . block
    (36) block -> . INDENT statements
    (37) block -> . INDENT statements DEDENT

    INDENT          shift and go to state 54

    block                          shift and go to state 77

state 74

    (40) target_list -> LPAREN expr . COMMA expr RPAREN
    (15) expr -> LPAREN expr . RPAREN
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    COMMA           shift and go to state 78
    RPAREN          shift and go to state 42
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 75

    (32) elif_stmt -> elif comp_op COLON . block
    (33) elif_stmt -> elif comp_op COLON . block elif_stmt
    (34) elif_stmt -> elif comp_op COLON . block else_block
    (36) block -> . INDENT statements
    (37) block -> . INDENT statements DEDENT

    INDENT          shift and go to state 54

    block                          shift and go to state 79

state 76

    (35) else_block -> else COLON block .

    $end            reduce using rule 35 (else_block -> else COLON block .)
    DEDENT          reduce using rule 35 (else_block -> else COLON block .)
    elif            reduce using rule 35 (else_block -> else COLON block .)
    else            reduce using rule 35 (else_block -> else COLON block .)
    NEWLINE         reduce using rule 35 (else_block -> else COLON block .)
    ID              reduce using rule 35 (else_block -> else COLON block .)
    LPAREN          reduce using rule 35 (else_block -> else COLON block .)
    print           reduce using rule 35 (else_block -> else COLON block .)
    if              reduce using rule 35 (else_block -> else COLON block .)
    for             reduce using rule 35 (else_block -> else COLON block .)
    while           reduce using rule 35 (else_block -> else COLON block .)
    INTEGER         reduce using rule 35 (else_block -> else COLON block .)
    STRING          reduce using rule 35 (else_block -> else COLON block .)
    FLOAT           reduce using rule 35 (else_block -> else COLON block .)


state 77

    (38) for_stmt -> for ID in range target_list COLON block .

    NEWLINE         reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    ID              reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    LPAREN          reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    print           reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    if              reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    for             reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    while           reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    INTEGER         reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    STRING          reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    FLOAT           reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    $end            reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    DEDENT          reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    elif            reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)
    else            reduce using rule 38 (for_stmt -> for ID in range target_list COLON block .)


state 78

    (40) target_list -> LPAREN expr COMMA . expr RPAREN
    (12) expr -> . expr PLUS term
    (13) expr -> . expr MINUS term
    (14) expr -> . term
    (15) expr -> . LPAREN expr RPAREN
    (16) term -> . term TIMES factor
    (17) term -> . term DIVIDE factor
    (18) term -> . factor
    (19) factor -> . INTEGER
    (20) factor -> . ID
    (21) factor -> . STRING
    (22) factor -> . FLOAT

    LPAREN          shift and go to state 12
    INTEGER         shift and go to state 18
    ID              shift and go to state 29
    STRING          shift and go to state 19
    FLOAT           shift and go to state 20

    expr                           shift and go to state 80
    term                           shift and go to state 11
    factor                         shift and go to state 17

state 79

    (32) elif_stmt -> elif comp_op COLON block .
    (33) elif_stmt -> elif comp_op COLON block . elif_stmt
    (34) elif_stmt -> elif comp_op COLON block . else_block
    (32) elif_stmt -> . elif comp_op COLON block
    (33) elif_stmt -> . elif comp_op COLON block elif_stmt
    (34) elif_stmt -> . elif comp_op COLON block else_block
    (35) else_block -> . else COLON block

  ! shift/reduce conflict for elif resolved as shift
  ! shift/reduce conflict for else resolved as shift
    $end            reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    DEDENT          reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    NEWLINE         reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    ID              reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    LPAREN          reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    print           reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    if              reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    for             reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    while           reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    INTEGER         reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    STRING          reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    FLOAT           reduce using rule 32 (elif_stmt -> elif comp_op COLON block .)
    elif            shift and go to state 64
    else            shift and go to state 65

  ! elif            [ reduce using rule 32 (elif_stmt -> elif comp_op COLON block .) ]
  ! else            [ reduce using rule 32 (elif_stmt -> elif comp_op COLON block .) ]

    elif_stmt                      shift and go to state 81
    else_block                     shift and go to state 82

state 80

    (40) target_list -> LPAREN expr COMMA expr . RPAREN
    (12) expr -> expr . PLUS term
    (13) expr -> expr . MINUS term

    RPAREN          shift and go to state 83
    PLUS            shift and go to state 23
    MINUS           shift and go to state 24


state 81

    (33) elif_stmt -> elif comp_op COLON block elif_stmt .

    $end            reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    DEDENT          reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    elif            reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    else            reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    NEWLINE         reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    ID              reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    LPAREN          reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    print           reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    if              reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    for             reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    while           reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    INTEGER         reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    STRING          reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)
    FLOAT           reduce using rule 33 (elif_stmt -> elif comp_op COLON block elif_stmt .)


state 82

    (34) elif_stmt -> elif comp_op COLON block else_block .

    $end            reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    DEDENT          reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    elif            reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    else            reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    NEWLINE         reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    ID              reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    LPAREN          reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    print           reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    if              reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    for             reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    while           reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    INTEGER         reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    STRING          reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)
    FLOAT           reduce using rule 34 (elif_stmt -> elif comp_op COLON block else_block .)


state 83

    (40) target_list -> LPAREN expr COMMA expr RPAREN .

    COLON           reduce using rule 40 (target_list -> LPAREN expr COMMA expr RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for NEWLINE in state 2 resolved as shift
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 2 resolved as shift
WARNING: shift/reduce conflict for print in state 2 resolved as shift
WARNING: shift/reduce conflict for if in state 2 resolved as shift
WARNING: shift/reduce conflict for for in state 2 resolved as shift
WARNING: shift/reduce conflict for while in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for elif in state 53 resolved as shift
WARNING: shift/reduce conflict for else in state 53 resolved as shift
WARNING: shift/reduce conflict for DEDENT in state 66 resolved as shift
WARNING: shift/reduce conflict for elif in state 79 resolved as shift
WARNING: shift/reduce conflict for else in state 79 resolved as shift
